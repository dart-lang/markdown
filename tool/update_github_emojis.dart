// Copyright (c) 2022, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:args/args.dart';

import 'package:markdown/src/legacy_emojis.dart' as legacy;

// REGEXP to parse github emoji api
RegExp parseGithubEmojiApi =
    RegExp(r'^[\ \t]+"(.*?)".*unicode\/([A-Fa-f0-9\-]+)\.png');

RegExp parseGithubEmojiUnicodeFromFilename =
    RegExp(r'.*unicode\/([A-Fa-f0-9\-]+)\.png');

// Get our emoji list from Githubs api.  We reconcile with our legacy emojis so that
// we don't change or break anything.
// There are essentially only TWO (2) emojis that change and the
// legacy emoji is still available with an alternate name.
// The 'beetle' emoji changes from `üêû` to `ü™≤`, legacy available as 'lady_beetle'.
// The 'cricket' emoji changes from `üèè` to `ü¶ó`, legacy available as 'cricket_game'.
// (if the -g flag us used to force using the Github unicode sequences for the
// emojis then additionally the 'email' emoji changes from '‚úâÔ∏è' to 'üìß')
final _emojisJsonRawUrl = 'https://api.github.com/emojis';
final _emojisFilePath = 'lib/src/emojis.dart';

/// Reference to emojis map within legacy_emojis.dart
final legacyEmojis = legacy.emojis;

/// AUTO GENERATED by [reconcile_emojis.dart] - this only needed to be done ONCE
/// during the reconciliation process with the legacy emojis.
/// This array is ONLY USED when the --useGithubUnicodes option is used to
/// minimize the visual differences in the output emojis.
const legacyEmojisUsedVariationModifier = [
  '263a',
  '2600',
  '2601',
  '2744',
  '2708',
  '260e',
  '2702',
  '2712',
  '270f',
  '2764',
  'd83c-de37',
  '2734',
  '3299',
  '3297',
  'd83c-dd70',
  'd83c-dd71',
  'd83c-dd7e',
  '2668',
  '203c',
  '2049',
  '303d',
  '26a0',
  '267b',
  '2747',
  '2733',
  '24c2',
  'd83c-de02',
  'd83c-dd7f',
  '23cf',
  '25b6',
  '25c0',
  '27a1',
  '2b05',
  '2b06',
  '2b07',
  '2197',
  '2198',
  '2199',
  '2196',
  '2195',
  '2194',
  '21aa',
  '21a9',
  '2934',
  '2935',
  '2139',
  '3030',
  '2714',
  '2716',
  '00a9',
  '00ae',
  '2122',
  '2611',
  '25aa',
  '25ab',
  '25fc',
  '25fb',
  '2660',
  '2663',
  '2665',
  '2666',
];

const errorSpecialReplacement = '\u{FFFD}'; // Special replacement character 'ÔøΩ'

const useOfGithubUnicodeSequencesWarning = '''
IMPORTANT NOTE: The use of the --useGithubUnicodes switch will force using
Github unicode sequences.
This option is essentially here only for completeness, not for
release use.
The slight visual differences of some emojis might also be another
reason using --useGithubUnicodes should be considered a *Breaking Change*.

Some test will fail because of the different unicode sequences
and the emojis.unit file would need to be updated to contain the new
expected Github versions of the unicode sequences of the emojis in order
for the tests to pass.
''';

/// The github api url will return a json map of alls emojis in form of
/// { 'shortcode':'emojifilename' ... }
/// The filenames are simply a list of all of the hex string of the
/// *essential* unicode codepoints representing the emoji.
/// These sequences exclude the unicode join zero width (0x200D) and
/// variation select (0xFE0F) modifiers. (We will need to add these in to
/// build our actually unicode strings representing the emoji).
/// Multiple unicode codepoints are separated by '-'.
/// Examples filenames (single and double code point examples):
///  - "https://github.githubassets.com/images/icons/emoji/unicode/1f643.png?v8"
///  - "https://github.githubassets.com/images/icons/emoji/unicode/1f1fa-1f1fe.png?v8"
///  - "https://github.githubassets.com/images/icons/emoji/unicode/1f469-1f469-1f467-1f466.png?v8"
/// NOTE: Some filenames will be github 'custom' emojis that have no unicode
/// equivalent and these will not have hex codepoints, only the github custom name.
/// We will ingore these (there are only a 19 and they are mostly pixel art from
/// the old Doom game).
/// Example github custom emoji filename:
///  - "https://github.githubassets.com/images/icons/emoji/godmode.png?v8",
String parseGithubFilenameIntoUnicodeString(String emojiFilename) {
  const variationSelector = 0xFE0F;
  const zeroWidthJoiner = 0x200D;

  try {
    final String? rawHexList =
        parseGithubEmojiUnicodeFromFilename.firstMatch(emojiFilename)?.group(1);
    if (rawHexList == null) {
      // This is a github custom emoji and it is represent by PNG only and
      // there is no equivalent unicode.  We have to ingore.
      return '';
    }
    bool legacyUsedVariationCode = false;
    if (legacyEmojisUsedVariationModifier.contains(rawHexList)) {
      legacyUsedVariationCode = true;
    }
    final List<int> rawCodePointsHex = rawHexList
        .split('-')
        .map((hexstr) => int.parse(hexstr, radix: 16))
        .toList();
    final List<int> codePointsHex = [];

    if (legacyUsedVariationCode) {
      // just add single variation selector
      codePointsHex.addAll(rawCodePointsHex);
      codePointsHex.add(variationSelector);
    } else {
      // now insert the join zero width and variation select modifying unicode chars
      for (var i = 0; i < rawCodePointsHex.length; i++) {
        final codePointAtIndex = rawCodePointsHex[i];
        codePointsHex.add(codePointAtIndex);
        if (i < (rawCodePointsHex.length - 1)) {
          codePointsHex.add(variationSelector);
          // # and 0-9 don't use zero width joiners.
          if (codePointAtIndex == 0x23 ||
              (codePointAtIndex >= 0x30 && codePointAtIndex <= 0x39)) {
            // no zerowidth joiner
          } else {
            codePointsHex.add(zeroWidthJoiner);
          }
        }
      }
    }
    return String.fromCharCodes(codePointsHex);
  } catch (e) {
    print('Invalid/Non-Conformant emoji filename encountered $emojiFilename !');
    return (errorSpecialReplacement);
  }
}

Future<void> main(List<String> args) async {
  final parser = ArgParser()
    ..addFlag('help',
        abbr: 'h', negatable: false, help: 'Print help text and exit.')
    ..addFlag('useGithubUnicodes',
        abbr: 'g',
        negatable: false,
        help: 'Use the github unicode sequences instead of legacy sequences.')
    ..addFlag('visualizeDifferentUnicodes',
        abbr: 'v',
        negatable: false,
        help: 'Visualize any unicode sequence differences.')
    ..addOption('dumpMarkdownShortCodes',
        abbr: 's',
        defaultsTo: 'missing',
        allowed: ['plain', 'tooltip'],
        allowedHelp: {
          'plain': 'just shortcode',
          'tooltip': '(shortcode with link to provide emoji name in tooltip)',
        },
        help:
            'Outputs all emoji shortcodes to stdout which can be used in markdown to show and tests all emojis.');
  late final ArgResults results;

  try {
    results = parser.parse(args);
  } catch (e) {
    printUsage(parser);
    return;
  }

  if (results['help'] as bool) {
    printUsage(parser);
    return;
  }

  int totalEmojisWithDifferentUnicodeSequences = 0;
  final bool useLegacyUnicodeSequences =
      !(results['useGithubUnicodes'] as bool);
  final bool visualizeUnicodeDiffs =
      results['visualizeDifferentUnicodes'] as bool;
  final bool dumpMarkdownShortCodes =
      (results['dumpMarkdownShortCodes'].toLowerCase() == 'plain');
  final bool dumpMarkdownToolTipShortCodes =
      (results['dumpMarkdownShortCodes'].toLowerCase() == 'tooltip');

  if (!useLegacyUnicodeSequences) {
    // issue warning
    print(useOfGithubUnicodeSequencesWarning);
  }
  if (visualizeUnicodeDiffs) {
    print(
        'The following emojis have different unicode sequences from those of legacy versions:');
  }
  final client = HttpClient();
  final request = await client.getUrl(Uri.parse(_emojisJsonRawUrl));
  final response = await request.close();
  final Map<String, String> shortcodeToEmoji = jsonDecode(
          await response.cast<List<int>>().transform(utf8.decoder).join(''))
      .map((String alias, dynamic filename) => MapEntry(
          alias, parseGithubFilenameIntoUnicodeString(filename as String)))
      .cast<String, String>() as Map<String, String>;

  // Now before we proceed we need to 'mix in' any legacy emoji alias shortcodes that
  // are missing from the github emoji list.
  legacyEmojis.forEach((String shortCodeAlias, String emojiUnicode) {
    if (!shortcodeToEmoji.containsKey(shortCodeAlias)) {
      shortcodeToEmoji[shortCodeAlias] = emojiUnicode;
    }
  });

  final emojisContent = StringBuffer('''
// GENERATED FILE. DO NOT EDIT.
//
// This file was generated from Githubs api emoji list end point:
// $_emojisJsonRawUrl
// at ${DateTime.now()} by the script, tool/update_github_emojis.dart.

''');
  emojisContent.writeln('const emojis = <String, String>{');
  var emojiCount = 0;
  final ignored = <String>[];
  final errored = <String>[];
  // Dump in sorted order now to facilitate comparison with new github emojis.
  final sortedKeys = shortcodeToEmoji.keys.toList()..sort();
  for (final String shortCodeAlias in sortedKeys) {
    String emojiUnicode = shortcodeToEmoji[shortCodeAlias]!;
    if (useLegacyUnicodeSequences &&
        legacyEmojis.containsKey(shortCodeAlias) &&
        shortCodeAlias != 'cricket' &&
        shortCodeAlias != 'beetle') {
      emojiUnicode = legacyEmojis[
          shortCodeAlias]!; // Use legacy unicode string if available
    }
    if (legacyEmojis.containsKey(shortCodeAlias) &&
        emojiUnicode != legacyEmojis[shortCodeAlias]) {
      totalEmojisWithDifferentUnicodeSequences++;
      if (visualizeUnicodeDiffs) {
        print(
            '$emojiUnicode was ${legacyEmojis[shortCodeAlias]} :$shortCodeAlias:');
      }
    }
    if (emojiUnicode != errorSpecialReplacement && emojiUnicode.isNotEmpty) {
      emojisContent.writeln("  '$shortCodeAlias': '$emojiUnicode',");
      if (dumpMarkdownShortCodes) {
        print(':$shortCodeAlias:');
      } else if (dumpMarkdownToolTipShortCodes) {
        print('[:$shortCodeAlias:](## "&colon;$shortCodeAlias&colon; emoji")');
      }
      emojiCount++;
    } else {
      if (emojiUnicode == errorSpecialReplacement) {
        errored.add(shortCodeAlias);
      } else {
        ignored.add(shortCodeAlias);
      }
    }
  }
  emojisContent.writeln('};');
  File(_emojisFilePath).writeAsStringSync(emojisContent.toString());

  if (dumpMarkdownShortCodes) {
    // No report so we don't put junk in our markdown we have
    // been outputing.
    exit(0);
  }

  print('''Wrote data to $_emojisFilePath for $emojiCount emojis,
$totalEmojisWithDifferentUnicodeSequences emoji's unicode sequences differ from legacy versions${!visualizeUnicodeDiffs ? " (run with -v flag to visualize)" : ""},
ignoring ${ignored.length}: ${ignored.join(', ')},
errored: ${errored.length} ${errored.join(', ')}.''');
  exit(0);
}

void printUsage(ArgParser parser) {
  print('''Usage: update_emojis.dart [--useGithubUnicodes | -l]

By default, the legacy unicode sequences are used (for
maximum visual compatability with the legacy emojis).
The --useGithubUnicodes flag can be used so that the 
unicode sequences from github are used for emoji's that
existed within the legacy set.  This will result in very slight visual
differences for some emojis, but it will result in many more
binary differences when comparing legacy_emoji.dart to emoji.dart.
$useOfGithubUnicodeSequencesWarning

The --visualizeDifferentUnicodes flag can be used to visually
verify that any different unicode sequences produce the same
emoji.

${parser.usage}
''');
}
